defmodule OHLCDynamicTest do
  use ExUnit.Case

  import OHLC
  import OHLCHelper

  doctest OHLC

  @timeframes [{:minute, 60}, {:hour, 3600}, {:day, 86_400}, {:week, 604_800}]

  # 2021-22-03 00:00:00 UTC +0
  @base_timestamp 1_616_371_200

  @doc """
  Creates dynamically one candle per timeframe and validates the candle returning
  true if the dynamically created candle is valid and false if not valid.
  One trade per second will be generated by default.
  If you'd like to generate less trades per candle then you can increase the size of
  the timeframe_divider variable(1-100).
  The fifth parameter is used for generating multiple candles of the same timeframe.
  """
  @spec test_single_candle(
          :minute | :hour | :day | :week,
          integer() | float(),
          integer() | float(),
          integer() | float(),
          integer(),
          integer()
        ) :: false | true
  def test_single_candle(
        timeframe,
        min_price,
        max_price,
        volume,
        timeframe_multiplier \\ 1,
        timeframe_divider \\ 1
      ) do
    # Create floats.
    min_price = (is_float(min_price) && Float.round(min_price, 4)) || min_price / 1
    max_price = (is_float(max_price) && Float.round(max_price, 4)) || max_price / 1
    volume = (is_float(volume) && Float.round(volume, 4)) || volume / 1

    trades =
      generate_single_candle_trades(
        @timeframes[timeframe],
        min_price,
        max_price,
        volume,
        timeframe_multiplier,
        timeframe_divider
      )

    {:ok, data} = create_candles(trades, timeframe)

    volume_to_check = trades_total_volume(trades)

    length(data[:candles]) === 1 and
      Enum.at(data[:candles], 0)[:high] === max_price and
      Enum.at(data[:candles], 0)[:low] === min_price and
      Enum.at(data[:candles], 0)[:open] === Enum.at(trades, 0)[:price] and
      Enum.at(data[:candles], 0)[:close] === Enum.at(trades, -1)[:price] and
      Enum.at(data[:candles], 0)[:trades] === length(trades) and
      Enum.at(data[:candles], 0)[:volume] === volume_to_check and
      Enum.at(data[:candles], 0)[:stime] ===
        get_time_rounded(Enum.at(trades, -1)[:time], timeframe, type: :down) and
      Enum.at(data[:candles], 0)[:etime] ===
        get_time_rounded(Enum.at(trades, -1)[:time], timeframe, format: :stamp) and
      Enum.at(data[:candles], 0)[:type] ===
        get_candle_type(Enum.at(data[:candles], 0)[:open], Enum.at(data[:candles], 0)[:close])
  end

  defp generate_single_candle_trades(
         timeframe,
         min_price,
         max_price,
         volume,
         timeframe_multiplier,
         timeframe_divider
       ) do
    price_range = (max_price - min_price) |> Float.round(4)

    timestamp_multipled = @base_timestamp + timeframe * timeframe_multiplier

    items_to_loop = ((timeframe - 1) / timeframe_divider) |> trunc()

    Enum.map(1..items_to_loop, fn numb ->
      numb_multiplied = numb * timeframe_divider

      price =
        cond do
          numb === 1 ->
            max_price

          numb === items_to_loop ->
            min_price

          true ->
            (price_range / numb_multiplied + min_price) |> Float.round(4)
        end

      price = (is_float(price) && Float.round(price, 4)) || price
      volume = (is_float(volume) && Float.round(volume, 4)) || volume

      [
        price: price,
        volume: volume,
        time: timestamp_multipled + numb_multiplied
      ]
    end)
  end
end
