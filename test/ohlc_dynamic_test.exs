defmodule OHLCDynamicTest do
  use ExUnit.Case

  import OHLC
  import OHLCHelper

  doctest OHLC

  @doc """
  Creates dynamically one candle per timeframe and validates the candle returning
  true if the dynamically created candle is valid and false if not valid.
  One trade per second will be generated by default.
  If you'd like to generate less trades per candle then you can increase the size of
  the timeframe_divider variable(1-100).
  The fifth parameter is used for generating multiple candles of the same timeframe.
  """
  @spec test_single_candle(
          :minute | :hour | :day | :week,
          integer() | float(),
          integer() | float(),
          integer() | float(),
          integer(),
          integer()
        ) :: false | true
  def test_single_candle(
        timeframe,
        min_price,
        max_price,
        volume,
        timeframe_multiplier \\ 1,
        timeframe_divider \\ 1
      ) do
    # Create floats.
    min_price = (is_float(min_price) && Float.round(min_price, 4)) || min_price / 1
    max_price = (is_float(max_price) && Float.round(max_price, 4)) || max_price / 1
    volume = (is_float(volume) && Float.round(volume, 4)) || volume / 1

    trades =
      gen_trades(
        timeframe,
        min_price,
        max_price,
        volume,
        timeframe_multiplier,
        timeframe_divider
      )

    {:ok, data} = create_candles(trades, timeframe)

    volume_to_check = trades_total_volume(trades)

    length(data[:candles]) === 1 and
      Enum.at(data[:candles], 0)[:high] === max_price and
      Enum.at(data[:candles], 0)[:low] === min_price and
      Enum.at(data[:candles], 0)[:open] === Enum.at(trades, 0)[:price] and
      Enum.at(data[:candles], 0)[:close] === Enum.at(trades, -1)[:price] and
      Enum.at(data[:candles], 0)[:trades] === length(trades) and
      Enum.at(data[:candles], 0)[:volume] === volume_to_check and
      Enum.at(data[:candles], 0)[:stime] ===
        get_time_rounded(Enum.at(trades, -1)[:time], timeframe, type: :down) and
      Enum.at(data[:candles], 0)[:etime] ===
        get_time_rounded(Enum.at(trades, -1)[:time], timeframe, format: :stamp) and
      Enum.at(data[:candles], 0)[:type] ===
        get_candle_type(Enum.at(data[:candles], 0)[:open], Enum.at(data[:candles], 0)[:close])
  end
end
