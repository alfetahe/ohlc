defmodule OHLCDynamicTest do
  use ExUnit.Case

  import OHLC
  import OHLCHelper

  doctest OHLC

  @doc """
  Creates dynamically one candle per timeframe and validates the candle returning
  true if the dynamically created candle is valid and false if not valid.
  One trade per second will be generated by default.
  If you'd like to generate less trades per candle then you can increase the size of
  the timeframe_divider variable(1-100).
  The fifth parameter is used for generating multiple candles of the same timeframe.
  """
  @spec test_single_candle(
          :minute | :hour | :day | :week,
          integer() | float(),
          integer() | float(),
          integer() | float(),
          integer(),
          integer()
        ) :: false | true
  def test_single_candle(
        timeframe,
        min_price,
        max_price,
        volume,
        timeframe_multiplier \\ 1,
        timeframe_divider \\ 1
      ) do
    # Create floats.
    min_price = (is_float(min_price) && Float.round(min_price, 4)) || min_price / 1
    max_price = (is_float(max_price) && Float.round(max_price, 4)) || max_price / 1
    volume = (is_float(volume) && Float.round(volume, 4)) || volume / 1

    trades =
      OHLCFactory.gen_trades(
        timeframe: timeframe,
        min_price: min_price,
        max_price: max_price,
        volume: volume,
        timeframe_multiplier: timeframe_multiplier,
        timeframe_divider: timeframe_divider
      )

    {:ok, data} = create_candles(trades, timeframe)

    volume_to_check = trades_total_volume(trades)

    assert length(data[:candles]) === 1
    assert Enum.at(data[:candles], 0)[:high] === max_price
    assert Enum.at(data[:candles], 0)[:low] === min_price
    assert Enum.at(data[:candles], 0)[:open] === Enum.at(trades, 0)[:price]
    assert Enum.at(data[:candles], 0)[:close] === Enum.at(trades, -1)[:price]
    assert Enum.at(data[:candles], 0)[:trades] === length(trades)
    assert Enum.at(data[:candles], 0)[:volume] === volume_to_check

    assert Enum.at(data[:candles], 0)[:stime] ===
             get_time_rounded(Enum.at(trades, -1)[:time], timeframe, type: :down)

    assert Enum.at(data[:candles], 0)[:etime] ===
             get_time_rounded(Enum.at(trades, -1)[:time], timeframe, format: :stamp)

    assert Enum.at(data[:candles], 0)[:type] ===
             get_candle_type(
               Enum.at(data[:candles], 0)[:open],
               Enum.at(data[:candles], 0)[:close]
             )
  end
end
